# 花了 42 天，我成功走完了算法学习从放弃到入门的第一步

# 也许是最不一样的算法入门

https://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/

https://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/

https://jyywiki.cn/OS/2024/lect1.md


## 1 算法学习的困惑

打开任何一本算法相关的书籍，大概率都是从排序开始讲起。我一直有这么一个困惑，不知道你有没有，就是为什么要学习排序算法？

如果你是一名程序员，排序对你而言很简单，比如 SQL 中使用“ORDER BY”，或者代码中使用“sort()”方法，就可以快速完成排序。

更可气的是，认真学习一段时间后，发现书上学来的排序算法，性能完全比不上这些简单的调用。

这就导致算法学习从实用驱动，变成了面试驱动，它成为了检测你学习和理解能力的工具。

另外，算法本身的复杂性，已经决定了它的学习过程很困难。再加上没了实用性，大多数人的学习方法也变成了死记硬背，学完就忘。

一不小心，学习算法就像学习英语一样，一次次地翻开书本，一次次地背到“abandon”后就无疾而终了。

有没有一种可能，学不好算法的原因不是因为我们自己，而是教科书的教学方式本身就是错的？

## 2 学习算法就是学习历史

为什么代码中简单的排序方法sort的调用，性能会比书上的排序算法要好。

原因很简单，书上的排序算法是上世纪五六十年代发明的，而你调用的是无数工程师在这之上优化后最新的算法。

计算机发展的时间太短了，让人很容易忽略它也是有历史的。

如果换做时间维度更长的数学，可能更容易理解。古希腊哲学家芝诺眼中的无穷悖论，跟牛顿莱布尼茨眼中的无穷问题能一样嘛。

也许你没听说过芝诺这个名字，在微积分的教课书上不会出现他，但是在任何一本介绍微积分发展的书籍中他都不会缺席。

人类对无穷问题的思考是一个循序渐进的过程，但是教科书会将微积分的答案和做法直接告诉你，而忽略了从问题到答案之间经历了怎样的思维过程。

算法书籍也有同样的毛病，书上每个算法的介绍都很完善，但它不会告诉你这个算法的出处，它的诞生过程，甚至可能走过的弯路。

把学习算法当作学习历史，重走一边从无到有的发现历程，理解这些思考的过程，比直接告诉我们答案更有助于我们记住逻辑，掌握算法的本质，甚至还能帮助理解计算机思维。

这次就让我们从排序算法的历史出发，看看如何学习这个算法的入门课。也许这次真能挖掘出你学习算法的原力，做到深入理解，灵活应用，说不定还有可能创新和发展。

## 3 数据大爆发

有没有考虑过，在没有计算机的时代数据是如何排序的？

古代县衙里，会有专门的书记员将公文，税收等文件分门别类归档，比如按照类别和日期进行排序，方便日后查找。

当数据多到人力不可为的时候该怎么办？

19 世纪末期，美国人口每年以 30% 的速度增长。1870 年，美国人口普查只涉及 5 个“调查科目”，到了 1880 年则增加到了 200 多个。为了完成 1880 年的人口普查，花费了 8 年时间。数据大爆发就成为当时亟待解决的问题。

当时的信息记录在一张卡片上，比如数字 `1` 可以这么打孔:

![IBM Punch Card 1](/doc/illustrations/ibmcardsort/IBM03_1.PNG)

面对一堆打好的卡片（数据），如何进行排序呢？比如，我们希望将一叠卡片按照年龄进行排序。

IBM 提供用于对打孔卡片进行排序的机器 IBM Sorters。

![IBM Type 82 Sorter](/doc/illustrations/ibmcardsort/IBM05.PNG)

IBM Sorter 有 13 个口袋，其中 12 个口袋对应卡片的 12 行，还有 1 个口袋用于空白、拒绝和错误。

在机器运行之前，需要确定要排序的列。例如，我们可以确定首先排序的列是年龄个位数所在的列，然后运行机器。

所有的卡片会按照年龄个位数从小到大依次掉到不同的口袋里。例如，年龄个位数为 0 的卡片会掉到一个口袋，年龄个位数为 1 的卡片会掉到另一个口袋，以此类推。

接下来，将年龄个位数排好序的卡片再次排序，这次需要将排序的列调整到年龄十位数所在的列。

这次所有年龄在 10-19 岁的会掉到一个口袋里，所有年龄在 20-29 岁的会掉到一个口袋，以此类推。

将不同口袋的卡片按序收集起来，就可以完成对所有年龄的排序。

熟悉排序算法的朋友，一定会发现这不就是基数排序（Radix Sort）嘛。

除了 IBM Sorter，IBM 还开发了一款叫做 IBM Collator 的机器。这种机器的功能类似于合并算法，可以将两堆已排序好的卡片合并成一堆。

![IBM 088 Collator](/doc/illustrations/ibmcardsort/IBM06.PNG)

这种机械式的排序方法虽然效率不高，但它为我们提供了一种重要的思路，即利用机器来完成大规模数据的处理。

你看计算机还没有到来，我们就已经看到基数排序和合并排序在现实中的应用。

[没有计算机的时代，数据如何排序？](IBMpunchcardsort.md)

## 4 拯救计算机的算力

上世纪 40 年代，计算机诞生了。人们发现数字逻辑电路可以用来代替人类用来计算，比如计算微分方程来求解弹道。

计算机设计中的逻辑和数学问题引起了冯·诺依曼的兴趣，他担任了研制小组的顾问，试图解决早期计算机的设计缺陷，最终设计出了一种新的存储程序计算机，即冯·诺依曼架构，这种设计奠定了现代计算机架构。

冯·诺依曼为了验证这种设计的可行性，选择排序作为主题，比较计算机执行这些算法所需的时间与专用排序机 IBM Collator 的处理速度。

这也是冯·诺依曼写的第一个程序，当年是写在手稿上，高德纳发现后将其改写为符号化的汇编语言。

![冯·诺依曼手稿](/doc/illustrations/mergesort/mergesorthistory01.png)

[归并排序的历史：冯·诺依曼的第一个计算机程序是怎么做出来的？](mergesort%20history.md)

人们发现计算机不仅可以实现冯·诺依曼做的简单合并，甚至可以实现完全的排序。

使用计算机排序，数据已经不是保持在卡片上，而是保持在连续的内存中，可以通过指针来移动。

这时候简单的排序自然而然的就产生了，比如冒泡排序，选择排序，插入排序等。

基本的思路就是在内存中给数据挪位置，类似于打麻将的时候马牌的过程。

![动图 插入排序](/doc/illustrations/Insertionsort/insertionsort01.gif)

[插入排序（Insertion Sort）：为什么效率不高，却是使用率最高的排序算法？](insertionsort.md)

随着计算机的推广，人们发现计算机的算力有 30% 都用在了排序上。

排序算法的内卷时代开始降临了。

为了释放排序使用的算力，各种编程技巧也同时进入到排序算法的领域，基于递归，分治思想实现的归并排序。

[归并排序（Merge Sort）：一个被所有教科书嫌弃的算法，我们为什么还要学？](mergesort.md)

![动图 归并排序的实现](/doc/illustrations/mergesort/mergesort0401.gif)

发现归并排序不好，浪费了太多的内存空间。1959 年英国科学家 Tony Hoare 同样根据递归，分治思想实现了快速排序。

![递归执行示意图](/doc/illustrations//Quicksort/quicksort07.png)

[快速排序（Quick Sort）：为什么快？](quicksort.md)

你又会发现快速排序虽然解决了浪费内存的问题，但它自身也有问题，它做不到稳定性的要求，就是相同的元素在排序的时候无法保证它们之间的顺序是排序一开始的顺序。

排序的数据保存在连续的内存中，使用的数据结构基本是数组。1964 年 加拿大科学家 J. W. J. Williams 创造性地使用堆这个数据结构来进行排序叫做堆排序。

![动图 堆排序过程示意图](/doc/illustrations/heapsort/heapsort13.gif)

[堆排序（Heap Sort）：我们学习它可能并不是为了排序](heapsort.md)

排序算法各有各的优势，哪种算法更好？评判标准是什么？

## 5 确定游戏规则

思考一个问题：有没有一种公平的、一致的评判方法来对比不同算法的性能？

这个问题在计算机科学发展的早期，一直没有答案。

你想想在下面这两个场景下，你如何判断算法的好坏？

场景一：使用 1 万条数据进行测试，算法 A 运行 1 毫秒，算法 B 运行 10 毫秒。

场景二：使用 100 万条数据进行测试，算法 A 运行 10000 毫秒，算法 B 运行 6000 毫秒。

数据量少的时候，算法 A 表现好；数据量大的时候，算法 B 表现好。算法 A 和算法 B 到底哪个更好？这个问题换一种问法就是：**如何制定一个标准来判断算法的好坏？**

1965 年 Juris Hartmanis 和 Richard Stearns 首先提出了算法复杂的的概念，科学家们开始思考这个问题。最终，**高德纳找到了方法将算法复杂度严格量化衡量，他也因此被称为“算法分析之父”。**

是的，就是那个写出《计算机程序设计艺术》的大牛——**高德纳**。

![高德纳](/doc/illustrations/bigo/bigo07.PNG)

高德纳算法复杂度分析的主要思想有两点：

1. **在比较算法快慢的时候，只需要考虑数据量特别大，大到无穷大的情况。**
为什么要考虑无穷大？因为计算机的发明就是为了处理大量数据的，而且数据会越来越多。

2. 决定算法快慢的因素虽然有很多，但是所有的因素都可以被分为两类： 第一类是不随数据变化的因素，第二类是随数据变化的因素。**衡量算法好坏时，只需要考虑随数据变化到近乎无穷大的情况。**

从此 big O 这个在数学上不太起眼的概念，通过高德纳的搭线，在计算机科学领域大放异彩。

我们可以把排序算法分成两个阵营：复杂度为 `O(n²)` 的冒泡排序，选择排序，插入排序；以及复杂度为 `O(nlog(n))` 的归并排序，快速排序，堆排序。

[如何清晰地理解算法复杂度 Big O?](../bigo.md)

## 6 回归排序的本质

排序算法走到 `O(nlog(n))` 这个阶段是否就到尽头了？

当然没有。

为什么不在乎 `4N log N` 算法和 `1N log N` 算法之间的差异？为什么 `O(nlog(n))` 就是最优？

这一切的答案，都需要我们回到最初的起点，回归排序的本质。

排序问题可以被认为是确定元素之间的相对顺序。对于任何给定的 `N` 个元素，都有 `N!`（N的阶乘）种可能的排列，我们的目标是找出那唯一的一种满足排序需求的排列。

在 `N` 个元素的 `N!` 种可能的排列中，最小的序列是将其中每一个元素从小到大排好序的那个序列。

假定有两个序列 `a1, a2,...,ai,...,an` 和 `b1, b2,...,bi,...,bn`，我们需要对它们的大小进行比较。

这两个序列的比较规则是这样的：我们从头开始逐个元素比较，直到找到它们之间的第一个不同的元素。例如，如果 `ai` 是第一个与 `bi` 不同的元素，且 `ai <= bi`，那么第一个序列就小于第二个序列。

**通过元素的比较挑出最小的一个排列，就是比较排序的本质。**

比较两个元素，就相当于猜数字游戏里面的一个提问，显然这个提问的答案只能是“是”或“否”。一个只有两种输出的问题最多只能将可能性空间切成两半，根据猜数字游戏的思路，最佳方法就是切成`50`和`50`。

![比较排序](/doc/illustrations/nlogn/onlogn%2002.png)

所以如果希望了解排序的本质，你就必须了解二分法，以及它跟排序算法之间的关系。

[一个游戏让你理解二分法的本质](guessgame.md)

[从二分法的本质出发，理解为什么排序算法的复杂度不可能小于 O(nlogn)](why%20nlogn%20is%20the%20best%20in%20the%20compare%20sort.md)

从这个本质出发，我们可以发现，比较排序的上限就是 `O(nlogn)`。

那么哪种排序更接近于排序的理论上限呢？就是每次比较都可以将结果五五分？

通过比较我们可以看到优化过的快速堆排序更接近理论上限。

![动图 快速堆排序示意图](/doc/illustrations/heapsort/heapsort14.gif)

[为什么排序算法还是不够快？](why%20sort%20algorithm%20is%20not%20quick.md)

上面介绍的排序本质，揭示了二分法和排序效率的关系。有没有一种可能，我们将三分法，四分法……等用于排序，那排序效率不就更更高了嘛。

这就是所谓的线性排序，你记不记得在 IBM Sort 使用的排序方式，它就是一种线性排序——基数排序。

比较排序的本质就像二分法游戏，然而除了二分法，还有三分法游戏。基数排序的本质就像是一个 N 分法。

[还是一个游戏，让你理解三分法的本质](weightingproblem.md)

这就是基数排序之所以高效的原因，它摆脱了比较的排序算法复杂度上限只能是 `O(NlogN)` 的命运。

然而，基数排序有其局限性。比如需要知道数据的范围或宽度，而且主要适用于整数和字符串。对于浮点数和复数，基数排序也不太合适。

## 7 工程学的务实与创新

上面关于排序算法历史的介绍，基本上覆盖了大多数算法书籍里介绍的排序算法。

而这些算法书籍介绍到这里大概就结束了。

回到文章开头的问题，我们学习历史的意义是什么？仅仅是了解历史吗？

应该不止这些，我们至少能学会应用，甚至创新和发展。现在我们连自己调用的 sort 方法使用的是什么排序都不知道。

为了追求极致的效率，现在的排序算法会根据不同的数据量选择不同的排序，这种排序方式统称为复合型排序算法。

目前大多数函数库中，通常采用的是TimSort算法——一种结合了插入排序和归并排序的复合型排序算法。

所以在文章的最后，我们知识应该了解站在巨人之间的这个排序算法究竟是怎样的。

[世界上最快的排序算法 Timsort，你每次调用 `.sort()` 方法时都在使用它](./Sort/timsort.md)

好了，这就是我花了 42 天，走完的算法学习从放弃到入门的第一步。

翻开算法书籍，排序，查找至少占一半的篇幅。希望这些内容能让你更轻松的踏入算法的殿堂。


