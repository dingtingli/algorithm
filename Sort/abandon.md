# 花了 42 天，我成功走完了算法学习从放弃到入门的第一步

# 也许是最不一样的算法入门

https://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/

https://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/

https://jyywiki.cn/OS/2024/lect1.md


## 1 算法学习的困惑

打开任何一本算法相关的书籍，大概率都是从排序开始讲起。我一直有这么一个困惑，不知道你有没有，就是为什么要学习排序算法？

如果你是一名程序员，排序对你而言很简单，比如 SQL 中使用“ORDER BY”，或者代码中使用“sort()”方法，就可以快速完成排序。

更可气的是，认真学习一段时间后，发现书上学来的排序算法，性能完全比不上这些简单的调用。

这就导致算法学习从实用驱动，变成了面试驱动，它成为了检测你学习和理解能力的工具。

另外，算法本身的复杂性，已经决定了它的学习过程很困难。再加上没了实用性，大多数人的学习方法也变成了死记硬背，学完就忘。

一不小心，学习算法就像学习英语一样，一次次地翻开书本，一次次地背到“abandon”后就无疾而终了。

有没有一种可能，学不好算法的原因不是因为我们自己，而是教科书的教学方式本身就是错的？

## 2 学习算法就是学习历史

为什么代码中简单的排序方法sort的调用，性能会比书上的排序算法要好。

原因很简单，书上的排序算法是上世纪五六十年代发明的，而你调用的是无数工程师在这之上优化后最新的算法。

计算机发展的时间太短了，让人很容易忽略它也是有历史的。

如果换做时间维度更长的数学，可能更容易理解。古希腊哲学家芝诺眼中的无穷悖论，跟牛顿莱布尼茨眼中的无穷问题能一样嘛。

也许你没听说过芝诺这个名字，在微积分的教课书上不会出现他，但是在任何一本介绍微积分发展的书籍中他都不会缺席。

人类对无穷问题的思考是一个循序渐进的过程，但是教科书会将微积分的答案和做法直接告诉你，而忽略了从问题到答案之间经历了怎样的思维过程。

算法书籍也有同样的毛病，每个算法的介绍都很完善，但它不会告诉你这个算法的出处，它的诞生过程，甚至可能走过的弯路。

把学习算法当作学习历史，重走一边从无到有的发现历程，理解这些思考的过程，比直接告诉我们答案更有助于我们记住逻辑，掌握算法的本质，理解计算机思维。

这次就让我们从排序算法的历史出发，看看如何学习这个算法的入门课。也许这次真能挖掘出你学习算法的原力，做到深入理解，灵活应用，说不定还有可能创新和发展。

## 3 数据大爆发

有没有考虑过，在没有计算机的时代数据是如何排序的？

古代县衙里，会有专门的书记员将公文，税收等文件分门别类归档，比如按照类别和日期进行排序，方便日后查找。

当数据多到人力不可为的时候该怎么办？

19 世纪末期，美国人口每年以 30% 的速度增长。1870 年，美国人口普查只涉及 5 个“调查科目”，到了 1880 年则增加到了 200 多个。为了完成 1880 年的人口普查，花费了 8 年时间。数据大爆发就成为当时亟待解决的问题。

当时的信息记录在一张卡片上，比如数字 `1` 可以这么打孔:

![IBM Punch Card 1](/doc/illustrations/ibmcardsort/IBM03_1.PNG)

面对一堆打好的卡片（数据），如何进行排序呢？比如，我们希望将一叠卡片按照年龄进行排序。

IBM 提供用于对打孔卡片进行排序的机器 IBM Sorters。

![IBM Type 82 Sorter](/doc/illustrations/ibmcardsort/IBM05.PNG)

IBM Sorter 有 13 个口袋，其中 12 个口袋对应卡片的 12 行，还有 1 个口袋用于空白、拒绝和错误。

在机器运行之前，需要确定要排序的列。例如，我们可以确定首先排序的列是年龄个位数所在的列，然后运行机器。

所有的卡片会按照年龄个位数从小到大依次掉到不同的口袋里。例如，年龄个位数为 0 的卡片会掉到一个口袋，年龄个位数为 1 的卡片会掉到另一个口袋，以此类推。

接下来，将年龄个位数排好序的卡片再次排序，这次需要将排序的列调整到年龄十位数所在的列。

这次所有年龄在 10-19 岁的会掉到一个口袋里，所有年龄在 20-29 岁的会掉到一个口袋，以此类推。

将不同口袋的卡片按序收集起来，就可以完成对所有年龄的排序。

熟悉排序算法的朋友，一定会发现这不就是基数排序（Radix Sort）嘛。

除了 IBM Sorter，IBM 还开发了一款叫做 IBM Collator 的机器。这种机器的功能类似于合并算法，可以将两堆已排序好的卡片合并成一堆。

![IBM 088 Collator](/doc/illustrations/ibmcardsort/IBM06.PNG)

这种机械式的排序方法虽然效率不高，但它为我们提供了一种重要的思路，即利用机器来完成大规模数据的处理。

[没有计算机的时代，数据如何排序？](IBMpunchcardsort.md)

## 4 拯救计算机的算力



## 5 回归排序的本质

## 6 工程学的务实与创新