# 花了 42 天，我成功走完了算法学习从放弃到入门的第一步

# 也许是最不一样的算法入门

https://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/

https://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/

https://jyywiki.cn/OS/2024/lect1.md


## 1 算法学习的困惑

打开任何一本算法相关的书籍，大概率都是从排序开始讲起。我一直有这么一个困惑，不知道你有没有，就是为什么要学习排序算法？

如果你是一名程序员，排序对你而言很简单，比如 SQL 中使用“ORDER BY”，或者代码中使用“sort()”方法，就可以快速完成排序。

更可气的是，认真学习一段时间后，发现书上学来的排序算法，性能完全比不上这些简单的调用。

这就导致算法学习从实用驱动，变成了面试驱动，它成为了检测你学习和理解能力的工具。

另外，算法本身的复杂性，已经决定了它的学习过程很困难。再加上没了实用性，大多数人的学习方法也变成了死记硬背，学完就忘。

一不小心，学习算法就像学习英语一样，一次次地翻开书本，一次次地背到“abandon”后就无疾而终了。

有没有一种可能，学不好算法的原因不是因为我们自己，而是教科书的教学方式本身就是错的？

## 2 学习算法就是学习历史

为什么代码中简单的排序方法sort的调用，性能会比书上的排序算法要好。

原因很简单，书上的排序算法是上世纪五六十年代发明的，而你调用的是无数工程师在这之上优化后最新的算法。

计算机发展的时间太短了，让人很容易忽略它也是有历史的。

如果换做时间维度更长的数学，可能更容易理解。古希腊哲学家芝诺眼中的无穷悖论，跟牛顿莱布尼茨眼中的无穷问题能一样嘛。

也许你没听说过芝诺这个名字，在微积分的教课书上不会出现他，但是在任何一本介绍微积分发展的书籍中他都不会缺席。

人类对无穷问题的思考是一个循序渐进的过程，但是教科书会将微积分的答案和做法直接告诉你，而忽略了从问题到答案之间经历了怎样的思维过程。

算法书籍也有同样的毛病，书上每个算法的介绍都很完善，但它不会告诉你这个算法的出处，它的诞生过程，甚至可能走过的弯路。

把学习算法当作学习历史，重走一边从无到有的发现历程，理解这些思考的过程，比直接告诉我们答案更有助于我们记住逻辑，掌握算法的本质，甚至还能帮助理解计算机思维。

这次就让我们从排序算法的历史出发，看看如何学习这个算法的入门课。也许这次真能挖掘出你学习算法的原力，做到深入理解，灵活应用，说不定还有可能创新和发展。

## 3 数据大爆发

有没有考虑过，在没有计算机的时代数据是如何排序的？

古代县衙里，会有专门的书记员将公文，税收等文件分门别类归档，比如按照类别和日期进行排序，方便日后查找。

当数据多到人力不可为的时候该怎么办？

19 世纪末期，美国人口每年以 30% 的速度增长。1870 年，美国人口普查只涉及 5 个“调查科目”，到了 1880 年则增加到了 200 多个。为了完成 1880 年的人口普查，花费了 8 年时间。数据大爆发就成为当时亟待解决的问题。

当时的信息记录在一张卡片上，比如数字 `1` 可以这么打孔:

![IBM Punch Card 1](/doc/illustrations/ibmcardsort/IBM03_1.PNG)

面对一堆打好的卡片（数据），如何进行排序呢？比如，我们希望将一叠卡片按照年龄进行排序。

IBM 提供用于对打孔卡片进行排序的机器 IBM Sorters。

![IBM Type 82 Sorter](/doc/illustrations/ibmcardsort/IBM05.PNG)

IBM Sorter 有 13 个口袋，其中 12 个口袋对应卡片的 12 行，还有 1 个口袋用于空白、拒绝和错误。

在机器运行之前，需要确定要排序的列。例如，我们可以确定首先排序的列是年龄个位数所在的列，然后运行机器。

所有的卡片会按照年龄个位数从小到大依次掉到不同的口袋里。例如，年龄个位数为 0 的卡片会掉到一个口袋，年龄个位数为 1 的卡片会掉到另一个口袋，以此类推。

接下来，将年龄个位数排好序的卡片再次排序，这次需要将排序的列调整到年龄十位数所在的列。

这次所有年龄在 10-19 岁的会掉到一个口袋里，所有年龄在 20-29 岁的会掉到一个口袋，以此类推。

将不同口袋的卡片按序收集起来，就可以完成对所有年龄的排序。

熟悉排序算法的朋友，一定会发现这不就是基数排序（Radix Sort）嘛。

除了 IBM Sorter，IBM 还开发了一款叫做 IBM Collator 的机器。这种机器的功能类似于合并算法，可以将两堆已排序好的卡片合并成一堆。

![IBM 088 Collator](/doc/illustrations/ibmcardsort/IBM06.PNG)

这种机械式的排序方法虽然效率不高，但它为我们提供了一种重要的思路，即利用机器来完成大规模数据的处理。

你看计算机还没有到来，我们就已经看到基数排序和合并排序在现实中的应用。

[没有计算机的时代，数据如何排序？](IBMpunchcardsort.md)

## 4 拯救计算机的算力

上世纪 40 年代，计算机诞生了。人们发现数字逻辑电路可以用来代替人类用来计算，比如计算微分方程来求解弹道。

计算机设计中的逻辑和数学问题引起了冯·诺依曼的兴趣，他担任了研制小组的顾问，试图解决早期计算机的设计缺陷，最终设计出了一种新的存储程序计算机，即冯·诺依曼架构，这种设计奠定了现代计算机架构。

冯·诺依曼为了验证这种设计的可行性，选择排序作为主题，比较计算机执行这些算法所需的时间与专用排序机 IBM Collator 的处理速度。

这也是冯·诺依曼写的第一个程序，当年是写在手稿上，高德纳发现后将其改写为符号化的汇编语言。

![冯·诺依曼手稿](/doc/illustrations/mergesort/mergesorthistory01.png)

[归并排序的历史：冯·诺依曼的第一个计算机程序是怎么做出来的？](mergesort%20history.md)

人们发现计算机不仅可以实现冯·诺依曼做的简单合并，甚至可以实现完全的排序。

使用计算机排序，数据已经不是保持在卡片上，而是保持在连续的内存中，可以通过指针来移动。

这时候简单的排序自然而然的就产生了，比如冒泡排序，选择排序，插入排序等。

基本的思路就是在内存中给数据挪位置，类似于打麻将的时候马牌的过程。

![动图 插入排序](/doc/illustrations/Insertionsort/insertionsort01.gif)

[插入排序（Insertion Sort）：为什么效率不高，却是使用率最高的排序算法？](insertionsort.md)

随着计算机的推广，人们发现计算机的算力有 30% 都用在了排序上。

排序算法的内卷时代开始降临了。

为了释放排序使用的算力，各种编程技巧也同时进入到排序算法的领域，基于递归，分治思想实现的归并排序。

[归并排序（Merge Sort）：一个被所有教科书嫌弃的算法，我们为什么还要学？](mergesort.md)

![动图 归并排序的实现](/doc/illustrations/mergesort/mergesort0401.gif)

发现归并排序不好，浪费了太多的内存空间。1959 年英国科学家 Tony Hoare 同样根据递归，分治思想实现了快速排序。

![递归执行示意图](/doc/illustrations//Quicksort/quicksort07.png)

[快速排序（Quick Sort）：为什么快？](quicksort.md)

你又会发现快速排序虽然解决了浪费内存的问题，但它自身也有问题，它做不到稳定性的要求，就是相同的元素在排序的时候无法保证它们之间的顺序是排序一开始的顺序。

排序的数据保存在连续的内存中，使用的数据结构基本是数组。1964 年 加拿大科学家 J. W. J. Williams 创造性地使用堆这个数据结构来进行排序叫做堆排序。

![动图 堆排序过程示意图](/doc/illustrations/heapsort/heapsort13.gif)

[堆排序（Heap Sort）：我们学习它可能并不是为了排序](heapsort.md)

排序算法各有各的优势，哪种算法更好？评判标准是什么？

## 5 确定游戏规则

思考一个问题：有没有一种公平的、一致的评判方法来对比不同算法的性能？

这个问题在计算机科学发展的早期，一直没有答案。

你想想在下面这两个场景下，你如何判断算法的好坏？

场景一：使用 1 万条数据进行测试，算法 A 运行 1 毫秒，算法 B 运行 10 毫秒。

场景二：使用 100 万条数据进行测试，算法 A 运行 10000 毫秒，算法 B 运行 6000 毫秒。

数据量少的时候，算法 A 表现好；数据量大的时候，算法 B 表现好。算法 A 和算法 B 到底哪个更好？这个问题换一种问法就是：**如何制定一个标准来判断算法的好坏？**

1965 年 Juris Hartmanis 和 Richard Stearns 首先提出了算法复杂的的概念，科学家们开始思考这个问题。最终，**高德纳找到了方法将算法复杂度严格量化衡量，他也因此被称为“算法分析之父”。**

是的，就是那个写出《计算机程序设计艺术》的大牛——**高德纳**。

![高德纳](/doc/illustrations/bigo/bigo07.PNG)

高德纳算法复杂度分析的主要思想有两点：

1. **在比较算法快慢的时候，只需要考虑数据量特别大，大到无穷大的情况。**
为什么要考虑无穷大？因为计算机的发明就是为了处理大量数据的，而且数据会越来越多。

2. 决定算法快慢的因素虽然有很多，但是所有的因素都可以被分为两类： 第一类是不随数据变化的因素，第二类是随数据变化的因素。**衡量算法好坏时，只需要考虑随数据变化到近乎无穷大的情况。**

从此 big O 这个在数学上不太起眼的概念，通过高德纳的搭线，在计算机科学领域大放异彩。

我们可以把排序算法分成两个阵营：复杂度为 `O(n²)` 的冒泡排序，选择排序，插入排序；以及复杂度为 `O(nlog(n))` 的归并排序，快速排序，堆排序。

[如何清晰地理解算法复杂度 Big O?](../bigo.md)

## 6 回归排序的本质



## 67 工程学的务实与创新