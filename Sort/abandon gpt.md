# 算法学习从放弃到入门的第一步，我花了 42 天终于走完了

## 1 算法学习的困惑

打开任何一本算法相关的书籍，我们常常看到它们从排序算法讲起。我一直有这么一个困惑，不知道你有没有，就是为什么要学习排序算法？

对于程序员而言，排序是一个简单的任务，比如 SQL 中使用“ORDER BY”，或者代码中使用“sort()”方法，就可以快速完成排序。

更让人觉得可气的是，认真学习一段时间后，我们发现书上学来的排序算法，性能完全比不上这些简单的调用。

这会让人很有挫败感，因为算法学习逐渐从实用驱动，变成了面试驱动，它成为了检测你学习和理解能力的工具。

此外，算法的固有复杂性确实使得其学习成为一项挑战。当学习变得抽象且缺乏直接的应用价值时，大多数人的学习方法也变成了死记硬背，学完就忘。

一不小心，学习算法就像学习英语一样，一次次地翻开书本，一次次地背到“abandon”后就无疾而终了。

有没有一种可能，学不好算法的原因不是因为我们自己，而是教科书的教学方式本身就是错的？

## 2 学习算法就是学习历史

为什么简单调用一个排序方法，其性能会超过许多教科书上的算法呢？

答案其实很简单：这些书中的算法大多源于上世纪五六十年代，而你所调用的，则是经过无数工程师优化之后的现代算法。

计算机发展的时间太短了，让人很容易忽略它也是有历史的。

以数学为例，我们可以更容易理解这一点。古希腊哲学家芝诺对无穷悖论的探索，与牛顿和莱布尼茨对无穷问题的处理，显然是不一样的。

你也许没听说过芝诺这个名字，因为在微积分的教科书中很少提及。然而，在介绍微积分发展历程的书籍里，他是绝对不能缺席的。

从问题到答案的过程中，人类对无穷问题的理解是渐进式的。但教科书往往只给我们最终的答案和方法，忽略了其中的思维过程。

算法书籍也存在这样的问题。书中对每个算法的介绍都很详尽，但它们略过了这些算法的发展历史，其诞生和演变的过程，以及可能走过的弯路。

这非常不符合人类大脑学习和记忆的过程。如果我们将这一环节补上，将算法学习视为一次历史之旅，会怎样呢？

重走一遍从无到有的发现历程，深入理解其中的思考过程，不仅有助于我们掌握算法的逻辑本质，也有利于理解计算机思维。

## 3 数据大爆发

在计算机时代到来之前，你有没有想过数据是如何被排序的？

在古代，县衙的书记员会手动将公文、税收等文件进行分类归档，通常依据类别和日期排序，以便于将来的检索。

但是，当数据量增长到超出人力可处理的范围时，应该如何应对呢？

到了 19 世纪末，随着美国人口的快速增长，人口普查的数据处理成为了一项巨大的挑战。从 1870 年的 5 个调查科目增加到 1880 年的 200 多个，仅完成 1880 年人口普查的工作就耗时长达 8 年，数据量的大爆炸成为了当时急需解决的问题。

当时，数据被记录在打孔卡片上，每张卡片上的孔洞代表了不同的信息。面对成堆的打孔卡片，如何有效进行排序成为了一个问题，比如如何根据年龄对卡片进行排序。

![数字 `1` 的打孔方式](/doc/illustrations/ibmcardsort/IBM03_1.PNG)

IBM 提供了一种解决方案，即 IBM Sorter 机器，专门用于对打孔卡片进行排序。

IBM Sorter 的工作原理，实际上是基数排序（Radix Sort）的一个物理实现。机器拥有 13 个口袋，其中 12 个用于分类卡片上对应的十二行信息，还有一个口袋用于处理空白、拒绝和错误的卡片。

![IBM Type 82 Sorter](/doc/illustrations/ibmcardsort/IBM05.PNG)

在排序开始前，操作员需要设置好机器，以确定哪一列数据将被用于排序。例如，如果我们首先根据年龄的个位数排序，机器便会按照这一标准运行，卡片将根据年龄的个位数被分配到不同的口袋中。

随后，通过对这些个位数已经排序的卡片进行进一步的排序——这次是依据年龄的十位数，我们可以完成全面的排序工作。

进一步地，IBM 还开发了 IBM Collator，这是一种能够实现两堆已排序卡片合并的机器。它的工作原理类似于合并排序算法，即将两组已经排序的数据合并成一组有序的数据集。

![IBM 088 Collator](/doc/illustrations/ibmcardsort/IBM06.PNG)

这些机械式的排序方法，效率远远高于当时的人力，它们向我们展示了利用机械化手段处理大规模数据的可能性。

在计算机发明之前，我们已经能够见证基数排序（Radix Sort）和合并排序在现实世界中的应用，这不仅是对技术创新的一种展示，也反映了算法和数据处理技术的发展是一个长期而渐进的过程。

[没有计算机的时代，数据如何排序？](IBMpunchcardsort.md)
